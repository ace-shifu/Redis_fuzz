%{
#include "bison_parser.h"
#include <stdio.h>
#include <sstream>
#include <string>
#include <cstring>
#define TOKEN(name) { return SQL_##name; }
static thread_local std::stringstream strbuf;
%}

%option reentrant
%option bison-bridge
%option never-interactive
%option batch
%option noyywrap
%option nounput
%option warn
%option case-insensitive
%option bison-locations
%option header-file="flex_lexer.h"
%option outfile="flex_lexer.cpp"
%option prefix="ff_"
%s COMMENT
%x singlequotedstring


%%
DEL TOKEN(DEL)
DUMP TOKEN(DUMP)
EXISTS TOKEN(EXISTS)
EXPIRE TOKEN(EXPIRE)
EXPIREAT TOKEN(EXPIREAT)
KEYS TOKEN(KEYS)
MIGRATE TOKEN(MIGRATE)
COPY TOKEN(COPY)
REPLACE TOKEN(REPLACE)
MOVE TOKEN(MOVE)
OBJECT TOKEN(OBJECT)
REFCOUNT TOKEN(REFCOUNT)
ENCODING TOKEN(ENCODING)
IDLETIME TOKEN(IDLETIME)
PERSIST TOKEN(PERSIST)
PEXPIRE TOKEN(PEXPIRE)
PEXPIREAT TOKEN(PEXPIREAT)
PTTL TOKEN(PTTL)
RANDOMKEY TOKEN(RANDOMKEY)
RENAME TOKEN(RENAME)
RENAMENX TOKEN(RENAMENX)
RESTORE TOKEN(RESTORE)
SORT TOKEN(SORT)
GET TOKEN(GET)
STORE TOKEN(STORE)
TTL TOKEN(TTL)
TYPE TOKEN(TYPE)

APPEND TOKEN(APPEND)
BITCOUNT TOKEN(BITCOUNT)
BITOP TOKEN(BITOP)
DECR TOKEN(DECR)
DECRBY TOKEN(DECRBY)
GETBIT TOKEN(GETBIT)
GETRANGE TOKEN(GETRANGE)
GETSET TOKEN(GETSET)
INCR TOKEN(INCR)
INCRBY TOKEN(INCRBY)
INCRBYFLOAT TOKEN(INCRBYFLOAT)
MGET TOKEN(MGET)
MSET TOKEN(MSET)
MSETNX TOKEN(MSETNX)
PSETEX TOKEN(PSETEX)
SET TOKEN(SET)
AND TOKEN(AND)
OR TOKEN(OR)
XOR TOKEN(XOR)
NOT TOKEN(NOT)
BY TOKEN(BY)
LIMIT TOKEN(LIMIT)
ASC TOKEN(ASC)
DESC TOKEN(DESC)
ALPHA TOKEN(ALPHA)
EX TOKEN(EX)
PX TOKEN(PX)
NX TOKEN(NX)
XX TOKEN(XX)
SETBIT TOKEN(SETBIT)
SETEX TOKEN(SETEX)
SETNX TOKEN(SETNX)
SETRANGE TOKEN(SETRANGE)
STRLEN TOKEN(STRLEN)
BEFORE TOKEN(BEFORE)
AFTER TOKEN(AFTER)
SUM TOKEN(SUM)
MIN TOKEN(MIN)
MAX TOKEN(MAX)
HDEL TOKEN(HDEL)
HEXISTS TOKEN(HEXISTS)
HGET TOKEN(HGET)
HGETALL TOKEN(HGETALL)
HINCRBY TOKEN(HINCRBY)
HINCRBYFLOAT TOKEN(HINCRBYFLOAT)
HKEYS TOKEN(HKEYS)
HLEN TOKEN(HLEN)
HMGET TOKEN(HMGET)
HMSET TOKEN(HMSET)
HSET TOKEN(HSET)
HSETNX TOKEN(HSETNX)
HVALS TOKEN(HVALS)
LINDEX TOKEN(LINDEX)
LINSERT TOKEN(LINSERT)
LLEN TOKEN(LLEN)
LPOP TOKEN(LPOP)
LPUSH TOKEN(LPUSH)
LPUSHX TOKEN(LPUSHX)
LRANGE TOKEN(LRANGE)
LREM TOKEN(LREM)
LSET TOKEN(LSET)
LTRIM TOKEN(LTRIM)
RPOP TOKEN(RPOP)
RPOPLPUSH TOKEN(RPOPLPUSH)
RPUSH TOKEN(RPUSH)
RPUSHX TOKEN(RPUSHX)
SADD TOKEN(SADD)
SCARD TOKEN(SCARD)
SDIFF TOKEN(SDIFF)
SDIFFSTORE TOKEN(SDIFFSTORE)
SINTER TOKEN(SINTER)
SINTERSTORE TOKEN(SINTERSTORE)
SISMEMBER TOKEN(SISMEMBER)
SMEMBERS TOKEN(SMEMBERS)
SMOVE TOKEN(SMOVE)
SPOP TOKEN(SPOP)
SRANDMEMBER TOKEN(SRANDMEMBER)
SREM TOKEN(SREM)
SUNION TOKEN(SUNION)
SUNIONSTORE TOKEN(SUNIONSTORE)
ZADD TOKEN(ZADD)
ZCARD TOKEN(ZCARD)
ZCOUNT TOKEN(ZCOUNT)
ZINCRBY TOKEN(ZINCRBY)
ZRANGE TOKEN(ZRANGE)
WITHSCORES TOKEN(WITHSCORES)
ZRANGEBYSCORE TOKEN(ZRANGEBYSCORE)
ZRANK TOKEN(ZRANK)
ZREM TOKEN(ZREM)
ZREMRANGEBYRANK TOKEN(ZREMRANGEBYRANK)
ZREMRANGEBYSCORE TOKEN(ZREMRANGEBYSCORE)
ZREVRANGE TOKEN(ZREVRANGE)
ZREVRANGEBYSCORE TOKEN(ZREVRANGEBYSCORE)
ZREVRANK TOKEN(ZREVRANK)
ZSCORE TOKEN(ZSCORE)
ZUNIONSTORE TOKEN(ZUNIONSTORE)
WEIGHTS TOKEN(WEIGHTS)
AGGREGATE TOKEN(AGGREGATE)
ZINTERSTORE TOKEN(ZINTERSTORE)
SELECT TOKEN(SELECT)


-?[0-9]+"."[0-9]* |
"."[0-9]* {
	yylval->fval = atof(yytext);
	return SQL_FLOATLITERAL;
	}

-?[0-9]+ {
	yylval->ival = atol(yytext);
	return SQL_INTLITERAL;
	}

\"[^\"\n]+\" {
	std::string s(yytext);
	yylval->sval = strdup(s.substr(1, s.size()-1).c_str());
	return SQL_STRINGLITERAL;
	}

[A-Za-z][A-Za-z0-9_*?]* {
	yylval->sval = strdup(yytext);
	return SQL_IDENTIFIER;
	
	}

[ \t\n]+ {
	}

. {
	return 0;
	}

%%
